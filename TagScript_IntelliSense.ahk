;----------------------------------------------------------
;Automatically generated by AutoHotkey. You can ignore that, but you should keep it nonetheless.
;----------------------------------------------------------
#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.
; #Warn  ; Enable warnings to assist with detecting common errors.
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
SetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.
;----------------------------------------------------------

;----------------------------------------------------------
;Carl-bot's TagScript IntelliSense/Macro Script by Asty' and LPB
;Based on the blocks at: https://docs.carl.gg/tags-and-triggers/tags-advanced-Keyword/
;----------------------------------------------------------

;---------------------------------
;Command Block
;---------------------------------
Hotstring( ":xc*:`{c`:", "commandblock")
Return

commandblock:
SendRaw, {c:}
Send {left}
Return

;---------------------------------
;Discord Objects
;---------------------------------

; --- {user} Object ---
:C*:{user::
SendRaw {user}
return

:C*:{uav::
SendRaw {user(avatar)}
return

:C*:{uid::
SendRaw {user(id)}
return

:C*:{umen::
SendRaw {user(mention)}
return

:C*:{ucat::
SendRaw {user(created_at)}
return

:C*:{ujat::
SendRaw {user(joined_at)}
return

:C*:{uco::
SendRaw {user(color)}
return

:C*:{uname::
SendRaw {user(name)}
return

:C*:{uprop::
SendRaw {user(proper)}
return

:C*:{uroles::
SendRaw {user(roleids)}
return

:C*:{urid::
SendRaw {user(roleids)}
return

:C*:{upos::
SendRaw {user(position)}
return

; --- {target} Object ---
:C*:{tar::
SendRaw {target}
return

:C*:{tav::
SendRaw {target(avatar)}
return

:C*:{tid::
SendRaw {target(id)}
return

:C*:{tm::
SendRaw {target(mention)}
return

:C*:{tcat::
SendRaw {target(created_at)}
return

:C*:{tjat::
SendRaw {target(joined_at)}
return

:C*:{tco::
SendRaw {target(color)}
return

:C*:{tname::
SendRaw {target(name)}
return

:C*:{tprop::
SendRaw {target(proper)}
return

:C*:{troles::
SendRaw {target(roleids)}
return

:C*:{trid::
SendRaw {target(roleids)}
return

:C*:{tpos::
SendRaw {target(position)}
return

; --- {server} Object---
:C*:{ser::
SendRaw {server}
return

:C*:{sic::
SendRaw {server(icon)}
return

:C*:{sav::
SendRaw {server(icon)}
return

:C*:{sid::
SendRaw {server(id)}
return

:C*:{sown::
SendRaw {server(owner)}
return

:C*:{sran::
SendRaw {server(random)}
return

:C*:{smem::
SendRaw {server(members)}
return

:C*:{shum::
SendRaw {server(humans)}
return

:C*:{sro::
SendRaw {server(roles)}
return

:C*:{sch::
SendRaw {server(channels)}
return

:C*:{scat::
SendRaw {server(created_at)}
return

; --- {channel} Object ---
:C*:{chan::
SendRaw {channel}
return

:C*:{cid::
SendRaw {channel(id)}
return

:C*:{ct::
SendRaw {channel(topic)}
return

:C*:{csm::
SendRaw {channel(slowmode)}
return

:C*:{cpos::
SendRaw {channel(position)}
return

:C*:{cm::
SendRaw {channel(mention)}
return

;---------------------------------
;Action Blocks
;---------------------------------

:C*:{del::
SendRaw {delete}
return

:C*:{sil::
SendRaw {silence}
return

:C*:{ov::
SendRaw {override}
return

;---------------------------------
;Redirection Blocks
;---------------------------------

:C*:{dm::
SendRaw {dm}
return

:C*:{red::
SendRaw {redirect:}
Send {left}
return

;---------------------------------
;Use Limiting Blocks
;---------------------------------

:C*:{req::
SendRaw {require():}
Send {left 3}
return

:C*:{bl::
SendRaw {blacklist():}
Send {left 3}
return

;---------------------------------
;Reaction Blocks
;---------------------------------

:C*:{rea::
SendRaw {react: }
Send {left}
return

:C*:{reu::
SendRaw {reactu: }
Send {left}
return

;---------------------------------
;Specific Command Blocks
;---------------------------------

:C*:{crole:: ; Command Role - Role User ID Block
SendRaw {c:role {user(id)} }
Send {left}
return

:C*:{cra:: ; Command Role Add - Role Add User ID Block
SendRaw {c:role add {user(id)} }
Send {left}
return

:C*:{crt:: ;  Command Role Target - Role Add Target ID Block
SendRaw {c:role add {target(id)} }
Send {left}
return

:C*:{crc:: ; Command Role Custom
SendRaw {c:role custom {user(id)} }
Send {left}
return

:C*:{cec:: ; Command Echo
SendRaw {c:echo }
Send {left}
return

:C*:{cem:: ; Command Cembed
SendRaw {c:cembed }
Send {left}
return

:C*:{cfeed:: ; Command Announce to Feed
SendRaw {override}
Send {enter}
SendRaw {c:feed announce myFeed Message to announce here}
return
;---------------------------------
;Condition Blocks
;---------------------------------

:C*:{if::
SendRaw {if():}
Send {left 3}
return

:C*:{any::
SendRaw {any(|):}
Send {left 4}
return

:C*:{or::
SendRaw {or(|):}
Send {left 4}
return

:C*:{all::
SendRaw {and(|):}
Send {left 4}
return

:C*:{and::
SendRaw {and(|):}
Send, {left 4}
return

:C*:{break::
SendRaw {break():}
Send {left 3}
return

;---------------------------------
;Variable Blocks (Data Storage)
;---------------------------------

:C*:{=::
SendRaw {=():}
Send {left 3}
return

:C*:{var::
SendRaw {=():}
Send {left 3}
return

:C*:{let::
SendRaw {=():}
Send {left 3}
return

;---------------------------------
;Arguments (Parsing)
;---------------------------------

:C*:{arg(::
SendRaw {args()}
Send {left 2}
return

:C*:{args::
SendRaw {args}
return

;---------------------------------
;List and Cycle Blocks
;---------------------------------

:C*:{li::
SendRaw {list():}
Send {left 3}
return

:C*:{cy::
SendRaw {cycle():}
Send {left 3}
return

:C*:{dex::
SendRaw {index():}
Send {left 3}
return

;---------------------------------
;Membership Test Operations (In and Contains)
;---------------------------------

:C*:{in::
SendRaw {in():}
Send {left 3}
return

:C*:{con::
SendRaw {contains():}
Send {left 3}
return

;---------------------------------
;Embed Blocks
;---------------------------------

:C*:{emt::
SendRaw {embed(title):}
Send {left}
return

:C*:{emu::
SendRaw {embed(url):}
Send {left}
return

:C*:{emd::
SendRaw {embed(description):}
Send {left}
return

:C*:{emc::
SendRaw {embed(color):#}
Send {left}
return

:C*:{emn::
SendRaw {embed(timestamp):now}
Send {left}
return

;---------------------------------
;Math Blocks
;---------------------------------

; --- Basic Math Block ---
:C*:{+::
SendRaw {m:}
Send {left}
return

; --- Mathematical Functions and Variables ---
:C*:{ma::
SendRaw {m:abs()}
Send {left 2}
return

:C*:{mr::
SendRaw {m:round()}
Send {left 2}
return

:C*:{mt::
SendRaw {m:trunc()}
Send {left 2}
return

:C*:{ms::
SendRaw {m:sgn()}
Send {left 2}
return

:C*:{mln::
SendRaw {m:ln()}
Send {left 2}
return

:C*:{mlog::
SendRaw {m:log()}
Send {left 2}
return

;---------------------------------
;RNG Blocks
;---------------------------------

; --- Random Blocks ---
:C*:{#(:: ; Seeded random block. Puts the cursor on the seed parameter.
SendRaw {#():}
Send {left 3}
return

:C*:{rand::
SendRaw {#:}
Send {left}
return

; --- Range Blocks ---
:C*:{rang:: ; range. Defaults to 1 for the lowest number.
SendRaw {range:1-}
Send {left}
return

:C*:{ranf:: ; rangef. Defaults to 1 for the lowest number.
SendRaw {rangef:1-}
Send {left}
return

; --- 50/50 Blocks ---
:C*:{50::
SendRaw {50:}
Send {left}
return

:C*:{%::
SendRaw {`%:}
Send {left}
return

;---------------------------------
;Time Blocks
;---------------------------------
; --- Strf Blocks ---
:C*:{strf(::
SendRaw {strf():}
Send {left}
return

; --- Strf % Time Data/Variables (You're going to love that one) ---
;	--Weekday--
; Mon - %a
:C*:%wds:: ; Weekday Short
SendRaw `%a
return

; Monday - %A
:C*:%wdf:: ; Weekday Full
SendRaw `%A
return

; 1 - %w
:C*:%wdn:: ; Weekday Number/Decimal
SendRaw `%w
return

;	--Month--
; 30 - %d
:C*:%md:: ; Month Day
SendRaw `%d
return

; 30 - %-d
:C*:%0md:: ; Zero-padded Month Day
SendRaw `%-d
return

; Sep - %b
:C*:%ms:: ; Month Short
SendRaw `%b
return

; September - %B
:C*:%mf:: ; Month Full
SendRaw `%B
return

; 9 - %m
:C*:%mn:: ; Month Number
SendRaw `%m
return

; 09 - %-m
:C*:%mn:: ; Zero-padded Month Number
SendRaw `%-m
return

;	--Year--
; 21 - %y
:C*:%ys:: ; Year Short
SendRaw `%y
return

; 2021 - %Y
:C*:%yf:: ; Year Full
SendRaw `%Y
return

;	--Hour--
; 07 - %H
:C*:%h024:: ; Zero-padded 24-hour clock Hour
SendRaw `%H
return

; 7 - %-H
:C*:%h24:: ; 24-hour clock Hour
SendRaw `%-H
return

; 07 - %I
:C*:%h012:: ; Zero-padded 12-hour clock Hour
SendRaw `%I
return

; 7 - %-I
:C*:%h12:: ; 12-hour clock Hour
SendRaw `%-I
return

; AM - %p
:C*:%am:: ; Locale’s equivalent of either AM or PM
SendRaw `%p
return

; AM - %p
:C*:%pm:: ; Locale’s equivalent of either AM or PM (just an alias of the previous one)
SendRaw `%p
return

;	--Minute--
; 06 - %M
:C*:%min:: ; Minute as a zero-padded decimal number
SendRaw `%M
return

;	--Second--
; 05 - %S
:C*:%0s:: ; Second as a zero-padded decimal number
SendRaw `%S
return

; 5 - %-S
:C*:%s:: ; Second as a decimal number
SendRaw `%-S
return

;	--Microsecond--
; 000000 - %f
:C*:%mis:: ; Microsecond as a decimal number, zero-padded on the left
SendRaw `%f
return

;	--Day of the Year--
; 273 - %j
:C*:%0yd:: ; Day of the year as a zero-padded decimal number
SendRaw `%j
return

; 273 - %-j
:C*:%yd:: ; Day of the year as a decimal number
SendRaw `%-j
return

; 273 - %j
:C*:%doty:: ; Just an alias of the previous one
SendRaw `%j
return

;	--Week number--
; 39 - %W
:C*:%wn:: ; Week number of the year (Monday as the first day of the week) as a decimal number. All days in a new year preceding the first Monday are considered to be in week 0
SendRaw `%W
return

;	--Locale's date and time representation (still in UTC)--
; Mon Sep 30 07:06:05 2021 - %c
:C*:%full:: ; Full date and time 
SendRaw `%c
return

; 09/30/13 - %x
:C*:%date:: ; Date separated by /
SendRaw `%x
return

; 07:06:05 - %X
:C*:%time:: ; Time separated by :
SendRaw `%X
return

; --- Timedelta Blocks ---
:C*:{td(:: ; td with parameter
SendRaw {td():}
Send {left 3}
return

;---------------------------------
;Manipulation Blocks
;---------------------------------

; --- Ordinal Abbreviation Blocks ---
:C*:{rd::
SendRaw {ord:}
Send {left}
return

; --- Case Blocks ---
:C*:{low::
SendRaw {lower:}
Send {left}
return

:C*:{upp::
SendRaw {upper:}
Send {left}
return

; --- Text Replacement Blocks ---
:C*:{join::
SendRaw {join():}
Send {left 3}
return

:C*:{rep::
SendRaw {replace():}
Send {left 3}
return

:C*:{url::
SendRaw {urlencode:}
Send {left}
return

:C*:{ur+::
SendRaw {urlencode(+):}
Send {left}
return

;---------------------------------
;Helpful Snippets
;---------------------------------

;Comments
:C*:{com::
SendRaw {=(comment):}
Send {left}
return

:C*:{COM::
SendRaw, {=(COMMENT):}
Send {left}
return

;Get the number of words in args and define it as a variable
:C*:{len::
SendRaw {=(Length):{index(&$):{args} &$}}
Send {enter}
return

;Make the first word of args all lowercase (helpful for standardising input)
:C*:{l1::
SendRaw {=(L1):{lower:{1}}}
Send {enter}:
return

;Make the entirety of args all lowercase (helpful for standardising input)
:C*:{larg::
SendRaw {=(Largs):{lower:{args}}}
Send {enter}:
return
;Make the first word of args all uppercase (helpful for standardising input)
:C*:{u1::
SendRaw {=(U1):{upper:{1}}}
Send {enter}:
return

;Make the entirety of args all uppercase (helpful for standardising input)
:C*:{larg::
SendRaw {=(Uargs):{upper:{args}}}
Send {enter}:
return

;Outputs "true" if args is a number, outputs "false" otherwise
:C*:{isnum::
SendRaw {in({m:sgn({args})}):-1 0 1}
return

;Converts the current time (or any time in unix form) to any time zone
:C*:{timezone::
SendRaw {=(offset):}
Send {enter}:
SendRaw {=(hins):3600}
Send {enter}:
SendRaw {=(output):{strf({m:trunc({unix}+({hins}*{offset}))}):`%-I:`%M `%p}}
Send {Up 2}
Send {End}
Send {left}:
return

;Generates a random color
:C*:{randhex::
SendRaw {=(i):#:A,B,C,D,E,F,0,1,2,3,4,5,6,7,8,9}
Send {enter}:
SendRaw {=(randomhex):{{i}}{{i}}{{i}}{{i}}{{i}}{{i}}}
return

;Sets the embed color to a random color
:C*:{randemc::
SendRaw {=(i):#:A,B,C,D,E,F,0,1,2,3,4,5,6,7,8,9}
Send {enter}:
SendRaw {embed(color):#{{i}}{{i}}{{i}}{{i}}{{i}}{{i}}}
return

;Test if {args(1)} is a valid hex color
:C*:{ishex::
SendRaw {=(uargs):{replace(#,):{upper:{args(1)}}}}
Send {enter}:
SendRaw {=(length):{index(`%^&):{replace(, ):{uargs}} `%^&}}
Send {enter}:
SendRaw {=(hex2num):{replace(A,10):{replace(B,11):{replace(C,12):{replace(D,13):{replace(E,14):{replace(F,15):{uargs}}}}}}}}
Send {enter}:
SendRaw {=(hextest):{m:trunc({join(+):{replace(, ):{hex2num}}})}}
Send {Enter 2}
SendRaw {=(error):#{uargs}}
Send {enter}:
SendRaw {=(error1):There are 6 characters in a Hexidecimal Color Code (no alpha values), try again.}
Send {enter}:
SendRaw {=(error2):Hexidecimal Color Codes should only contain digits 0-9 and letters A-F, there is an invalid character present, try again.}
Send {Enter 2}
SendRaw {error{if({length}!=6):1|{if({hextest}!={m:trunc({hextest}/1)}):2}}}
return

;Add a cooldown role to the user
:C*:{cooldown::
SendRaw {=(cdRole):RoleIDHere}
Send {enter}:
SendRaw {=(cdTime):5m}
Send {enter}:
SendRaw {blacklist(You need to wait {cdTime} before using the command again.):{cdRole}}
Send {enter}:
SendRaw {override}{silence}
Send {enter}:
SendRaw {c:temprole {user(id)} {cdTime} {cdRole}}
Send {Up 5}
Send {End}
Send {left}:
return

;Capitalize the first letter of each word in args
:C*:{firstcap::
SendRaw {replace( z, Z):{replace( y, Y):{replace( x, X):{replace( w, W):{replace( v, V):{replace( u, U):{replace( t, T):{replace( s, S):{replace( r, R):{replace( q, Q):{replace( p, P):{replace( o, O):{replace( n, N):{replace( m, M):{replace( l, L):{replace( k, K):{replace( j, J):{replace( i, I):{replace( h, H):{replace( g, G):{replace( f, F):{replace( e, E):{replace( d, D):{replace( c, C):{replace( b, B):{replace( a, A): {args}}}}}}}}}}}}}}}}}}}}}}}}}}}
return

;Count the instances of a character in args (character can't be a comma, parentheses, or curly brackets)
:C*:{count::
SendRaw {=(charactertocount):}
Send {enter}:
SendRaw {=(arglength):{index($`%&):{args} $`%&}}
Send {enter}:
SendRaw {=(newarglength):{index($`%&):{replace({charactertocount},. .):{args}} $`%&}}
Send {enter}:
SendRaw {=(charactercount):{m:trunc({newarglength}-{arglength})}}
Send {enter}:
SendRaw {charactercount} `{charactertocount}` in the args
Send {Up 5}
Send {End}
Send {left}:
return

;Outputs a target mention, even if args is the target's id
:C*:{idmen::
SendRaw {if({in(@):{args}}==true):{args}|<@{args}>}
return

;Get an animated server icon (use {icon} instead of {server(icon)} in your tag)
:C*:{aicon::
SendRaw {=(icon):{if({in(a_):{server(icon)}}==true):{replace(png,gif):{server(icon)}}|{server(icon)}}}
return

;Round to the nearest number
:C*:{round::
SendRaw {=(numtoround):}
Send {enter}:
SendRaw {=(decplace):3}
Send {enter}:
SendRaw {m:round({num}*(10^{decplace}))/(10^{decplace})}
Send {Up 2}
Send {End}
Send {left}:
return

;Send an embed conditionally
:C*:{embedcond::
SendRaw {=():}
Send {enter}:
SendRaw {{if(boolean):blacklist(Error message that will be send instead of the embed):{server(id)}}}
Send {Home}
Send {Right 5}
return

;Switch method
:C*:{switch::
SendRaw {=(L1):{lower:{1}}}
Send {enter}:
SendRaw {=({L1}):Error message here}
Send {enter}:
SendRaw {=():Output for first variable}
Send {enter}:
SendRaw {=():Output for second variable}
Send {enter}:
SendRaw {=():Output for third variable}
Send {enter}:
SendRaw {{L1}}
return